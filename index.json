[{"content":"Today\u0026rsquo;s quick post will give you reproducible steps to create a scale model of your home or apartment. I was inspired to create a few scale models as some of my friends have bought an apartment this year and I was looking for unique secret Santa gifts. Having a scale model with scale furniture helps visualize the space and helps you create a floor plan before you get the keys to your new house or apartment.\nDesign considerations There are a few things you can think about to make the scale model fit your expectations. For example, half height walls will make it easier to put little furniture inside. Also, the way windows and doors are modeled can have an impact on the durability of the model.\nIn my case, I have chosen to model everything at 1/10th the real size. Because a house is significantly larger than a 3D printer print bed, modeling it with real dimensions would result in a scaling factor in the slicing software of around 1%. This is tricky, can lose small details and might make for thin and vulnerable walls.\nI made my first model with walls at a third of the normal height. This is a good height in my opinion, but part of the window frames and front door were not connected at the top. This makes the window frames fragile and I would recommend connecting them at the top to improve the strength of the model. The next models I made also had taller outer walls with complete window frames, which further improved the model rigidity. Increasing the wall height has only little impact on the printing time as the most time is spent making the floor or bottom of the model.\nModeling instructions for Onshape By following these instructions you get a scale model at scale 1:10.\nCreate a new sketch in the XY plane and draw the outer walls. Dimension them using the real measurement divided by 10 to get a model at scale 1:10. Create another sketch in the XY plane and draw the inner walls. Dimension them using the real measurement divided by 10 to get a model at scale 1:10. Use the thin extrude function to extrude the outer walls with thickness 1 set to 26mm. By only setting thickness 1, we ensure the area remains the same as in the floor plan. Use a depth of around 200mm. Use the thin extrude function to extrude all the vertical inner walls with thickness 1 and 2 both set to 5mm. Use a depth of around 160mm. We extrude the inner walls with two operations, because the thin extrude operation can not handle Y or T sections of walls. Use the thin extrude function to extrude all the horizontal inner walls with thickness 1 and 2 both set to 5mm. Use a depth of around 160mm. Create some sketches on the inner walls to create the doors. My doors are 91mm wide. Use the extrude remove operation up to next or blind. Create some sketches on the outer walls to create the windows. You can use a couple extrude remove operations to create the windows, windowsills and frames. You can select a sketch and copy paste it to create more windows. Create a new sketch in the XY plane to create a floor. Use the line or rectangle tool to make sure it covers all the walls. Extrude the floor with a depth of around 12mm. If you have more than one body in the project, you can use the boolean union operation to combine all the parts into a single body. Export the body as a .stl file. Import the .stl file in your slicer. Scale the model to fit your build plate. In my case I went with 16% for a total scale of 1:62.5. You are now ready to print. Below I have included an example of how the Onshape interface will look like after following the steps. Note how the front door and window frames have a solid bar across them to improve the strength of the model. This is another example of how the model can look after 3D printing. Scale model furniture To bring the model to live, I have also modeled and printed some furniture. Most of it is from IKEA, but I also measured some other pieces from other stores. Feel free to take these models and print them. You can click the model and download the .stl directly. Printing is best done with the same scaling percentage as used for the house or apartment itself.\nKing Sized Bed (IDANÄS) Queen Sized Bed (IDANÄS) Small Double Sized Bed (IDANÄS) Dining Table (LISABO) Dining Table (TARSELE) Dining Table Extended (TARSELE) Dining Table (VOXLOV) Dining Table (VIHALS) Dining Chair (type A) Dining Chair (type B) Closet (PAX) Closet (VISTHUS) Closet (BRIMNES) Couch with 2 Seats (KIVIK) Couch with 3 Seats (KIVIK) Couch with Corner Seats (KIVIK) Television Stand Washing Machine When putting it all together, it will look something like this. In the following close up photo, the queen sized bed, Visthus closet and Tarsele table are displayed.\nClosing Thoughts The scale models are a big hit with friends and family and not that hard to make once you get the hang of it. If you print more than one in the same scale, you can reuse the furniture and play around a bit. The printing time can be quite long depending on your model as the first few layers are usually printed at reduced speed and our floor is relatively big and solid.\n","permalink":"https://driftingbits.github.io/posts/scale_model_house/","summary":"\u003cp\u003eToday\u0026rsquo;s quick post will give you reproducible steps to create a scale model of your home or apartment. I was inspired to create a few scale models as some of my  friends have bought an apartment this year and I was looking for unique secret Santa gifts. Having a scale model with scale furniture helps visualize the space and helps you create a floor plan before you get the keys to your new house or apartment.\u003c/p\u003e","title":"Scale Model House"},{"content":"In this post we will look at how we can design our own tracks and 3D print them as a low-cost and made to measure alternative to commercially available options. Tracks on a robot can help distribute the weight across a larger contact area. Along with the ability for the tracks to stretch and deform a bit, this makes the robot able to travel across both softer and rougher terrain.\nDesigning the tracks If you look at a set of tracks they might seem complicated, but in reality you only need to design one segment and a way to connect multiple copies together. It is important to note how much distance you want to have between two segments. We call this distance the pitch and it is the most important measurement to make sure the track will fit on a sprocket. In turn, it also determines the minimum diameter of the sprockets and rollers you will need to get the tracks to turn smoothly. If you go for bigger segments, you will end up with bigger sprockets and possibly more ground clearance.\nI used the spreadsheet functionality within Freecad to make it easy to change the width and tolerance in my design. It is possible to reference the values in the spreadsheet from the Part Design workbench and have your part update it\u0026rsquo;s dimensions everytime you make a change to the spreadsheet. For me, this came in handy as I initially designed the segments to have a 1mm clearance everywhere, but this resulted in a very loose track that easily derails. After halving the value for the clearance in the spreadsheet, I could easily export the modified part as an .stl again and print it.\nTo speed up the printing process, I used the Cura slicer to print a sequence of segments in one go. Since the segments do not have a very large contact area with the print bed, it is possible they pop off. This will ruin your print and the risk increases the more segments you try to print at once. In my case printing 6-12 segments in one go worked best.\nDesigning the sprocket To design the sprocket, we start with drawing an N-point polygon with an even number of sides. Having drawn the polygon, we can constrain the length of the sides to the pitch length. We will also draw a circle around the polygon and extrude it. This will be the size of the desired sprocket. We can now create a new sketch and project one of the points of the polygon to draw the groove where the track will sit and create a pocket. Using the polar array, we can duplicate the grooves in a circular pattern to create the final sprocket.\nUsing the sprocket, it is possible to create a wheel with a sprocket on both sides. You can use this wheel in your design to drive and/or guide your tracks.\nPutting it all together To connect all the track segments together, I used 1mm galvanized steel wire used in gardening. The amount of links you need to connect together depends on the distance between the two sprockets. To cover the distance, you will need at least as many segments as sides of the polygon used to create the sprocket. Then you need to take the distance between the center of the sprockets and divide it by the length of a single segment. By multiplying this number by two and adding the number of sides of the polygon, you get how many segments you will need. If the resulting track is too loose, you can consider adding an additional non-driven guide wheel or removing a link or two.\nClosing thoughts For my demo, I created one driven wheel powered by a yellow TT gear motor. The other wheel is not connected to anything and spins freely. If I decide to create a tracked robot in the future, I would consider increasing the diameter of the sprockets to increase the ground clearance. It would also be beneficial to add some smaller guide sprockets to make sure the track stays aligned well if the distance between the wheels is increased.\n","permalink":"https://driftingbits.github.io/posts/robot-tracks/","summary":"\u003cp\u003eIn this post we will look at how we can design our own tracks and 3D print them as a low-cost and made to measure alternative to commercially available options. Tracks on a robot can help distribute the weight across a larger contact area. Along with the ability for the tracks to stretch and deform a bit, this makes the robot able to travel across both softer and rougher terrain.\u003c/p\u003e","title":"Robot Tracks"},{"content":"In this post, we look at the process of building a Rubik\u0026rsquo;s cube solver. It uses affordable parts in combination with 3D printing and is a good beginner to intermediate project in case you want to build something similar.\nProject goals I noticed I have been spending quite a bit of time online looking at projects done by other people. Sometimes this can give you inspiration, but it is also possible to get stuck doomscrolling. So, I decided to pick up a new project that I can build from start to finish in a few days whilst learning more about 3D modeling.\nIt is important to me to actually finish something. Usually I stop when the interesting parts are done and move on to something new. Not this time, though. To achieve this I will limit the scope and take shortcuts when necessary. There will be no computer vision to recognize the colour of the squares and you will have to enter the scrambled state manually on the command line instead. I also ended up glueing my pieces to a cardboard base instead of screwing them in with the nice countersink holes I designed.\nHardware used 1x Raspberry Pi 2B (1GB RAM) 1x PCA9685 Servo Driver 8x SG90 Analog Servo 1x Moyu RS3M Magnetic Speed Cube For this build I used parts and hardware that I had already laying around. The most expensive part is the Raspberry Pi 2B, but this can also be substituted with a different single-board computer or microcontroller. One good alternative is the Raspberry Pi Zero 2W. It is newer, smaller and cheaper than the full-sized Raspberry Pi 2. During the build, I particularly liked connecting to the Raspberry Pi over wifi using SSH to upload and run new code. When working with microcontrollers and external power sources before, I was always a bit scared to fry a USB port on my laptop trying to flash new software.\nWhen it comes to the SG90 servos, you really do get what you pay for. It is almost impossible to find genuine servos and I\u0026rsquo;m sure I bought knock-offs of knock-offs. From the lot of 20 I bought, about half of them were dead on arrival. Some didn\u0026rsquo;t respond at all and others seemed to have the gears glued together. Also, I don\u0026rsquo;t think the SG90 servos are strong enough to turn an original Rubik\u0026rsquo;s cube. For this project, I am using a magnetic speed cube which has very low friction to turn the sides and can even be turned when the sides are not perfectly aligned.\nDesigning and printing the 3D models Wanting to get better at 3D design and CAD is a big reason why I choose this project. I have very limited prior 3D modeling experience and decided to create all the models in FreeCAD as this is free and open-source software without license restrictions. Earlier in 2024, the 1.0 version of FreeCAD was released which shows how far the project has come. I would consider it quite usable, if not a bit rough around the edges.\nThe design for the rotating and moving mechanism is the same for all four sides of the cube that will be rotated. In total this results in four different models. One gripper, one moving arm, one base and a gear . If you are interested, the .stl files are present in the github repository. Please take a look at the pictures below to see how they are shaped.\nOne of the big challenges was to get all the parts to fit correctly. If you design a hole with a 3mm diameter, the hole may not actually be 3mm after 3D printing. The filament is squished out of the nozzle resulting in slightly inaccurate prints. As a rule of thumb, I designed all holes 7% larger than they had to be and this worked out fine. I also measured the sides of the Rubik\u0026rsquo;s cube for the gripper and scaled this with 7%, but this turned out not so fine. As you may guess, this part was printed way too big.\nMy favourite thing about 3D printing is the rapid prototyping. I\u0026rsquo;m using an Ender 3 v3 SE and it levels itself and prints reasonably fast. By designing small parts to check the dimensions, you can get the fit right and then move on to the actual design. I found this saves me some filament and makes me more confident in the final design.\nMaking the servo motors move Every servo needs to be connected to a power source and a control signal. The control signal is controlled with Pulse-Width Modulation (PWM) and determines the servo\u0026rsquo;s position. The PWM signal is a digital signal created by quickly turning on and off a pin. The Raspberry Pi 2B has only two hardware PWM channels, but it is also possible to write software to generate a slightly less accurate signal on any digital output pin.\nInstead of using software based PWM, we will instead connect an external PCA9685 servo driver. This driver can generate 16 PWM signals and can be connected with our Raspberry Pi using only four wires using the I2C bus. The I2C protocol is a serial communication protocol that connects a master (Raspberry Pi) to multiple slave devices (servos). Every device has it\u0026rsquo;s own address, so we can send our command to move a specific servo to the bus and all the other listening devices will ignore it.\nThe Fritzing diagram below shows how to connect the servos, the PCA9685 servo driver and the Raspberry Pi together:\nThe easiest way to move a servo motor is shown in the following Python snippet. It will rotate a servo motor 90 degrees and back again, like shown in the gif. As we are using a Raspberry Pi running a full Linux operating system, it is possible to use Python instead of C or C++. A Python library to work with the servo driver shield is provided by Adafruit to get us started as quickly as possible. Notice how we initialize the ServoKit with 16 channels, which will give us an array of 16 servos we can individually control. And all that with only four wires connected from the Raspberry Pi to the servo driver!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Sweep a single servo motor back and forth from adafruit_servokit import ServoKit import time STEP_DELAY = 0.005 kit = ServoKit(channels=16) while True: for deg in range(0, 91): kit.servo[0].angle = deg time.sleep(STEP_DELAY) time.sleep(1) for deg in range(90, -1, -1): kit.servo[0].angle = deg time.sleep(STEP_DELAY) time.sleep(1) The Raspberry Pi is quite fast and would be able to execute the code above without sleep statements, but the servo wouldn\u0026rsquo;t be able to keep up. If you tell it to rotate and then switch the rotation direction, it would just jerk from one side to the other without ever reaching the desired end position. To prevent this we added some sleep statements, but admittedly this is a flawed solution.\nThe sleep statements effectively cause the processor to stall. It\u0026rsquo;s not doing anything and we lose cpu cycles that could have been put to better use. To illustrate this, consider we want to make our program interactive and take an angle from user input. If the user input is only read every 10 seconds because we told the processor to sleep, this makes for a very poor user experience with high latency. Similarly, it would be difficult to move more than one or two servos at a time.\nTo remove the sleep statements, we can take inspiration from video games. Video games and graphics are usually updated with 30, 60 or even more frames per second (FPS). If you press the left arrow key to move, your character doesn\u0026rsquo;t just teleport, but usually move smoothly to the left instead. This is exactly the same we want to achieve with our servo motors.\nWe can create a loop and update our desired servo position every iteration. If you have a specific rotation speed in mind, you can use the time an iteration takes as a delta time and multiply it by the speed to get the distance it should move. After the servo has reached it\u0026rsquo;s desired position you stop updating it or set the speed to zero. In the video game industry, the time between iterations is also known as the frame time. In case a refresh rate of 60 FPS is targeted, this would result in 0.0167 seconds to compute all the updates. Any slower and you will start to see frame stuttering or \u0026rsquo;lag\u0026rsquo;, and the same is true with our servos.\nIn the case of my Rubik\u0026rsquo;s cube solver, however, I don\u0026rsquo;t really care if there are any sleep statements as I don\u0026rsquo;t expect any kind of user input. The program will first calculate a solution and then start turning the faces until the cube is solved. If you are fine with a similar approach, you can look at the snippet below. I created a wrapper class that keeps track of the servo position and if it is moving. If it is not moving, we consider it idle or done.\n1 2 3 4 5 # Rotate clockwise rotation_servo.rotate_clockwise() while not rotation_servo.is_idle(): rotation_servo.update() time.sleep(0.005) If we write some more of these blocks, we can rotate any servos in any sequence we want in order to solve the cube. Take for example the snippet and gif below. It shows a method used to tilt the cube forwards to be able to rotate the top face. It consists of a sequence of steps. First, we need to ensure the gripper servos are rotated correctly before the tilting operation. To do this, we need to move an arm away from the cube, then rotate it, and then move the arm back in. Then, we can tilt the cube. Finally, we need to ensure the servos are back in the correct starting orientation.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def tilt_forward(): # Set up sides for rotation # Move back linServoB.move_backward() while not linServoB.is_idle(): linServoB.update() time.sleep(0.005) time.sleep(0.5) # Rotate counter clockwise rotServoB.rotate_counter_clockwise() while not rotServoB.is_idle(): rotServoB.update() time.sleep(0.005) time.sleep(0.5) # Move forward linServoB.move_forward() while not linServoB.is_idle(): linServoB.update() time.sleep(0.005) time.sleep(0.5) # Move front and back out of the way. linServoA.move_backward() linServoD.move_backward() while not linServoA.is_idle() and not linServoD.is_idle(): linServoA.update() linServoD.update() time.sleep(0.005) time.sleep(0.5) # Rotate both B and C together. B rotates left. C rotates right. rotServoB.rotate_clockwise() rotServoC.rotate_counter_clockwise() while not rotServoB.is_idle() and not rotServoC.is_idle(): rotServoB.update() rotServoC.update() time.sleep(0.005) time.sleep(0.5) # Move front and back in. linServoA.move_forward() linServoD.move_forward() while not linServoA.is_idle() and not linServoD.is_idle(): linServoA.update() linServoD.update() time.sleep(0.005) time.sleep(0.5) # C needs to finish the sequence to end up in the starting position. # Move back linServoC.move_backward() while not linServoC.is_idle(): linServoC.update() time.sleep(0.005) time.sleep(0.5) # Rotate clockwise rotServoC.rotate_clockwise() while not rotServoC.is_idle(): rotServoC.update() time.sleep(0.005) time.sleep(0.5) # Move forward linServoC.move_forward() while not linServoC.is_idle(): linServoC.update() time.sleep(0.005) time.sleep(0.5) One last thing I want to mention here is that 90 degrees in the code is not actually 90 degrees in real life. I created a mapping between the physical degrees and the degrees in the code in order to improve the accuracy. My cheap servos are rated for 180°, but the real range of motion is more like 110°. This is also the reason why my Rubik\u0026rsquo;s cube solver can only rotate a face 90° at a time before it needs to move back the gripper to reset the orientation to rotate the face any further.\nSolving Rubik\u0026rsquo;s cubes Some might call this cheating, but I used a Python library to get the list of moves needed to solve a given Rubik\u0026rsquo;s cube. The library uses the beginner\u0026rsquo;s method to solve the cube and spits out a list of moves like [F (front clockwise), U (up clockwise), R (right clockwise), L\u0026rsquo; (left counter-clockwise)]. The Python code just reads through this list, executes the movement and moves on to the next move until the cube is finished. The solution can be found quickly on a Raspberry Pi, but is not optimal. When executing the movements with the harware we built, it can take up to about two minutes to turn all the faces and solve a scrambled cube.\nThe reason I didn\u0026rsquo;t write a solver from scratch myself now, is that I have already done it three years ago as part of an university assignment for a course in distributed computing. The solver used Iterative Deepening Search (IDS) to find the smallest number of moves needed to solve a randomly scrambled cube of any size. By dividing the search space over multiple compute nodes in a six-cluster wide-area distributed system, it was possible to study how the algorithm scaled with more compute resources. In an ideal world, we want linear or even superlinear scaling: twice the hardware results in half the execution time. Unfortunately this is not always feasible because of overhead. If you are interested, this is one of the speedup graphs to illustrate how distributed algorithms can scale.\nThe first implementation (blue) achieves a higher speedup with more processes. In this version, a dedicated master process distributes the work across the other nodes. With a low amount of processes this means the master is mostly idle. The second implementation (orange) also uses a master process to distribute the work, but the master node itself also does some calculations in between. When running with only two processes, the second implementation is faster. But as the number of processes increases, we see the speedup will plateau because the master can not keep up when doing both the solving and coordination.\nClosing thoughts All in all, I consider this project a success. I\u0026rsquo;m glad I took some shortcuts and managed to finish the project on time and before starting something else. This is my first blog post and I look forward to writing more often to reflect on things I did and things I learned. If you liked it, please share the page with a friend and stay tuned for new posts.\n","permalink":"https://driftingbits.github.io/posts/rubiks-cube-solver/","summary":"\u003cp\u003eIn this post, we look at the process of building a Rubik\u0026rsquo;s cube solver. It uses affordable parts in combination with 3D printing and is a good beginner to intermediate project in case you want to build something similar.\u003c/p\u003e\n\u003ch2 id=\"project-goals\"\u003eProject goals\u003c/h2\u003e\n\u003cp\u003eI noticed I have been spending quite a bit of time online looking at projects done by other people. Sometimes this can give you inspiration, but it is also possible to get stuck doomscrolling. So, I decided to pick up a new project that I can build from start to finish in a few days whilst learning more about 3D modeling.\u003c/p\u003e","title":"Rubik's Cube Solver"}]